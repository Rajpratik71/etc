HOME_DIR=~wolfwzr

if [ "$(uname -s)" = "Darwin" ]
then
    OS_TYPE="osx"
else
    OS_TYPE="linux"
fi

if [ "$OS_TYPE" = "linux" ]
then
    grep "model name" /proc/cpuinfo | grep -s -q "Atom" && CPU_TYPE="Atom"
fi

# environment variable for vim script - vim-colorselector
export DOTVIM="$HOME_DIR/.vim/bundle/vim-colorschemes"
# variable for cscope
export CSCOPE_EDITOR=vim

############################################################
# basic functions
############################################################
function get_current_shell ()
{
    if [ "$OS_TYPE" = "linux" ]
    then
        basename $(readlink /proc/$$/exe)
    else
        if [ "$BASH" != "" ]
        then
            echo "bash"
        elif [ "$ZSH_NAME" != "" ]
        then
            echo "zsh"
        elif [ "$version" != "" ]
        then
            echo "tcsh"
        elif [ "$shell" != "" ]
        then
            # csh or tcsh
            basename "$shell"
        elif [ "$PS4" != ""]
        then
            echo "ksh"
        fi
    fi
}
CURRENT_SHELL=$(get_current_shell)

# source target file if file exist
function safe_source ()
{
    [ -f "$1" ] && source "$1"
}

# check if command is available
function cmd_available ()
{
    local cmd=$1
    which "$cmd" >/dev/null 2>&1
}

# add a item to PATH variable
function append_to_path()
{
    local new_path=$1

    [ -z "$new_path" ] && return
    echo $PATH | grep -s -q ":${new_path}[:$]"
    [ $? -ne 0 ] && PATH="$PATH:$new_path"
    export PATH
}

function uniq_path()
{
    eval "export PATH=\"$(tr ':' '\n' <<< "$PATH" | sort -r | uniq \
                        | tr '\n' ':' | sed 's/:$//g')\""
}

# update command prompt
function wolf_update_ps1()
{
    local exit_code=$?
    local last_cmd_exit_code
    local time
    local username
    local work_dir
    local prefix
    local suffix

    if [ $exit_code -ne 0 ]
    then
        # reverse on error ✘
        #last_cmd_exit_code="\[\033[35;7m\]${exit_code}✘"

        # warnning in PS1 head
        last_cmd_exit_code="\[\033[35;40m\]${exit_code}✘\[\033[0m\]"
    fi

    if [ "$TERMINAL_PROFILE" = "Light" ]
    then
        prefix="\[\033[47;37m\]"
    else
        prefix="\[\033[40;37m\]"
    fi
    prefix="$prefix\[\033[37m\]["

    time="\[\033[37m\]\t"
    if [ "$UID" = '0' ]
    then
        username="\[\033[35m\]\u"
    else
        username="\[\033[38m\]\u"
    fi
    at="\[\033[33m\]@"
    hostname="\[\033[37m\]\h"
    work_dir="\[\033[33m\]\W"
    suffix="\[\033[37m\]]\[\033[0m\]"

    export PS1="$last_cmd_exit_code$prefix$username$at$hostname $work_dir$suffix "
}

############################################################
# useful functions
############################################################

function copy_string ()
{
    if [ "$OS_TYPE" = "osx" ]
    then
        echo -n -E "$*" | pbcopy
    else
        echo -n -E "$*" | xclip -selection clipboard
    fi
}

function copy_file ()
{
    local file=${1:--}

    if [ "$OS_TYPE" = "osx" ]
    then
        pbcopy < "$file"
    else
        xclip -selection clipboard < "$file"
    fi
}

function whichpkg ()
{
    local fullpath

    fullpath=$(whence -p $1)
    [ $? -eq 0 ] && rpm -qf $fullpath
}

function lspkgfile ()
{
    local pkg

    pkg=$(whichpkg $1)
    [ $? -ne 0 ] && pkg=$1
    rpm -ql $pkg
}

function filecmd ()
{
    file $(which $1)
}

function get_website_favicon()
{
    local host=$1
    local h=$(echo $host | awk -F '.' '{print $1}')
    if [ -n "$host" -a -n "$h" ]
    then
        wget "http://$host/favicon.ico" -O "$h.ico"
    fi
}

function show_cmd_info ()
{
    local cmd=$1
    local type_info
    local man_info

    type_info=$(type $cmd)
    if [ "$type_info" = "$cmd is a shell builtin" ] || \
       [ "$type_info" = "$cmd is a shell function" ] || \
       echo "$type_info" | grep -sq "^$cmd is an alias"
    then
        echo "$type_info"
        #echo "use 'typeset -f $cmd' to print function definition"
        #echo "use 'help $cmd' in bash to get builtin help"
    else
        man_info=$(apropos --exact --regex --sections=1,1p "^$cmd$" 2>/dev/null)
        if [ $? -eq 0 ]
        then
            echo "$man_info"
        else
            echo "$type_info"
        fi
    fi
}

function lscmd ()
{
    local keyword=$1
    local CMD_INDEX="/tmp/.cmd.index"

    if [ ! -f "$CMD_INDEX" ]
    then
        case "$CURRENT_SHELL" in
            bash)
                compgen -A function -abck
                ;;
            zsh)
                echo ${(k)aliases} ${(k)functions} \
                     ${(k)builtins} ${(k)commands} | \
                     tr ' ' '\n'
                ;;
        esac | sort | uniq > "$CMD_INDEX"
    fi

    if [ "$keyword" = "" ]
    then
        echo "Usage: $0 <keyword>"
        return
    fi

    grep "$keyword" "$CMD_INDEX" | while read cmd
    do
        show_cmd_info $cmd
    done | tr -s ' ' | sed 's/^\([^ ]*\) /\1※/g' | column -t -s '※' | \
    grep --color=auto "$keyword"
}

# cd and ls
cls () { cd $1; ls;}

# mkdir and cd
mcd () { mkdir -p $1 && cd $1;}
